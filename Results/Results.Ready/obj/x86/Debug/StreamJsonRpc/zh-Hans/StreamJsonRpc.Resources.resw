<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TaskWasCancelled" xml:space="preserve">
    <value>任务已取消。</value>
  </data>
  <data name="StreamDisposed" xml:space="preserve">
    <value>已释放流</value>
  </data>
  <data name="InboundMessageOnly" xml:space="preserve">
    <value>此操作仅适用于入站消息。</value>
  </data>
  <data name="UnableToFindMethod" xml:space="preserve">
    <value>无法在 {2} 上找到方法“{0}/{1}”，出现如下错误: {3}</value>
  </data>
  <data name="ReservedPropertyName" xml:space="preserve">
    <value>此属性名称由 JSON-RPC 规范或此库保留。</value>
  </data>
  <data name="OutboundMessageOnly" xml:space="preserve">
    <value>此操作仅适用于出站消息。</value>
  </data>
  <data name="ResponseIsNotError" xml:space="preserve">
    <value>响应不是错误。</value>
  </data>
  <data name="UnexpectedErrorProcessingJsonRpc" xml:space="preserve">
    <value>处理 JSON-RPC 消息时出现意外错误: {0}</value>
  </data>
  <data name="CancellationTokenMustBeLastParameter" xml:space="preserve">
    <value>CancellationToken 只能用作最后一个参数。</value>
  </data>
  <data name="ElementsAlreadyPrefetched" xml:space="preserve">
    <value>此枚举已预提取了一次元素。</value>
  </data>
  <data name="UsableOnceOnly" xml:space="preserve">
    <value>此操作只能对此对象执行一次。</value>
  </data>
  <data name="TypedArgumentsLengthMismatch" xml:space="preserve">
    <value>此列表的长度必须等于参数列表的长度。</value>
  </data>
  <data name="UnsupportedEventHandlerTypeOnClientProxyInterface" xml:space="preserve">
    <value>“{0}”上不受支持的事件处理程序类型。只支持 EventHandler 和 EventHandler&lt;T&gt;。</value>
  </data>
  <data name="ParameterObjectsNotSupportedInJsonRpc10" xml:space="preserve">
    <value>JSON-RPC 1.0 不支持命名参数(在对象中传递的参数)。请使用位置参数(参数数组)或将协议版本设置为 2.0。</value>
  </data>
  <data name="TargetObjectAndMethodStaticFlagMismatch" xml:space="preserve">
    <value>当且仅当方法不是静态时，才提供目标对象。</value>
  </data>
  <data name="UnrecognizedIncomingJsonRpc" xml:space="preserve">
    <value>传入的 JSON-RPC 消息不符合已识别的模式。</value>
  </data>
  <data name="UnexpectedResponseWithNoMatchingRequest" xml:space="preserve">
    <value>在未发送请求的情况下收到响应。</value>
  </data>
  <data name="TextEncoderNotApplicable" xml:space="preserve">
    <value>不支持文本编码，因为格式化程序“{0}”未实现“{1}”。</value>
  </data>
  <data name="MarshalableInterfaceHasProperties" xml:space="preserve">
    <value>无法封送具有属性的接口。</value>
  </data>
  <data name="ConflictingMethodNameAttribute" xml:space="preserve">
    <value>“{0}”方法的所有重载和重写必须共享 {1}.{2} 的常见值。</value>
  </data>
  <data name="ReadingJsonRpcStreamFailed" xml:space="preserve">
    <value>从流读取 JSON RPC 失败，异常为 {0}: {1}</value>
  </data>
  <data name="ConnectionDropped" xml:space="preserve">
    <value>在请求完成之前, 与远程方的 JSON-RPC 连接已丢失。</value>
  </data>
  <data name="DroppingRequestDueToNoTargetObject" xml:space="preserve">
    <value>已获取执行“{0}”的请求，但没有回调对象。正在删除该请求。</value>
  </data>
  <data name="FormatterConfigurationLockedAfterJsonRpcAssigned" xml:space="preserve">
    <value>配置已锁定，因为此格式化程序已与 JsonRpc 实例关联。</value>
  </data>
  <data name="PositiveIntegerRequired" xml:space="preserve">
    <value>必须提供一个正整数。</value>
  </data>
  <data name="StreamMustBeWriteable" xml:space="preserve">
    <value>流必须可写。</value>
  </data>
  <data name="ResponseUnexpectedFormat" xml:space="preserve">
    <value>响应为意外格式。仅支持错误和结果: {0}</value>
  </data>
  <data name="JsonRpcCannotBeNull" xml:space="preserve">
    <value>JSON RPC 不得为 Null。</value>
  </data>
  <data name="BothReadableWritableAreNull" xml:space="preserve">
    <value>readable 和 writable 均为 null。</value>
  </data>
  <data name="FillBufferFirst" xml:space="preserve">
    <value>缓冲区为空。请先调用异步方法进行填充。</value>
  </data>
  <data name="ReachedEndOfStream" xml:space="preserve">
    <value>已达到流的结尾。</value>
  </data>
  <data name="HeaderValueTooLarge" xml:space="preserve">
    <value>邮件标头的大小超出了支持的最大大小。</value>
  </data>
  <data name="ResponseSerializationFailure" xml:space="preserve">
    <value>未能序列化响应。</value>
  </data>
  <data name="MarshalableInterfaceNotDisposable" xml:space="preserve">
    <value>封送的接口必须扩展 IDisposable。</value>
  </data>
  <data name="FailureDeserializingJsonRpc" xml:space="preserve">
    <value>序列化传入 JSON RPC“{0}”失败: {1}</value>
  </data>
  <data name="JsonRpcMethodAndIgnoreAttributesFound" xml:space="preserve">
    <value>在同一方法上发现冲突的 JsonRpcMethodAttribute 和 JsonRpcIgnoreAttribute: {0}。</value>
  </data>
  <data name="RpcMethodNameNotFound" xml:space="preserve">
    <value>找不到名为“{0}”的方法。</value>
  </data>
  <data name="SumOfTwoParametersExceedsArrayLength" xml:space="preserve">
    <value>{0} 和 {1} 参数超出了数组的长度。</value>
  </data>
  <data name="UnsupportedPropertiesOnClientProxyInterface" xml:space="preserve">
    <value>服务接口不支持属性。</value>
  </data>
  <data name="NonNegativeIntegerRequired" xml:space="preserve">
    <value>必须提供一个非负整数。</value>
  </data>
  <data name="MethodParametersNotCompatible" xml:space="preserve">
    <value>{0} 参数与请求中提供的参数不兼容。</value>
  </data>
  <data name="MustBeListening" xml:space="preserve">
    <value>必须先开始侦听。</value>
  </data>
  <data name="ParameterNotObject" xml:space="preserve">
    <value>参数不是单对象的形式</value>
  </data>
  <data name="MustNotBeListening" xml:space="preserve">
    <value>侦听开始后，无法完成此操作。</value>
  </data>
  <data name="MarshalableInterfaceHasEvents" xml:space="preserve">
    <value>无法封送具有事件的接口。</value>
  </data>
  <data name="InvalidAfterListenHasStarted" xml:space="preserve">
    <value>启动消息侦听后不允许此操作。</value>
  </data>
  <data name="HeaderContentLengthNotParseable" xml:space="preserve">
    <value>无法将 Content-Length 标头分析为一个正整数。</value>
  </data>
  <data name="RelayAlreadySet" xml:space="preserve">
    <value>已建立中继连接。</value>
  </data>
  <data name="FailureDeserializingRpcResult" xml:space="preserve">
    <value>未能将 JSON-RPC 结果反序列化为类型 {0}，出现 {1}: {2}</value>
  </data>
  <data name="TaskNotCompleted" xml:space="preserve">
    <value>任务未完成。</value>
  </data>
  <data name="MethodHasRefOrOutParameters" xml:space="preserve">
    <value>{0} 具有 ref 或 out 参数，不受支持</value>
  </data>
  <data name="FailureDeserializingRpcArgument" xml:space="preserve">
    <value>未能将名称为“{0}”且位置为 {1} 的 JSON-RPC 参数反序列化为类型“{2}”: {3}</value>
  </data>
  <data name="InvalidBeforeListenHasStarted" xml:space="preserve">
    <value>启动消息侦听前不允许此操作。</value>
  </data>
  <data name="NotSupportedWithoutMultiplexingStream" xml:space="preserve">
    <value>此配置中不支持带外流/管道。是否在格式化程序上设置了 MultiplexingStream?</value>
  </data>
  <data name="RequiredArgumentMissing" xml:space="preserve">
    <value>没有为所需参数提供参数。</value>
  </data>
  <data name="ConflictingMethodAttributeValue" xml:space="preserve">
    <value>.NET 方法“{0}”和“{1}”不能映射到同一请求方法名“{2}”。</value>
  </data>
  <data name="StreamMustBeReadable" xml:space="preserve">
    <value>流必须可读。</value>
  </data>
  <data name="ErrorWritingJsonRpcMessage" xml:space="preserve">
    <value>写入 JSON RPC 消息时出错: {0}: {1}</value>
  </data>
  <data name="EnumValueNotRecognized" xml:space="preserve">
    <value>值 {0} 不在枚举类型已识别或支持的成员中。</value>
  </data>
  <data name="MarshaledObjectInResponseOrNotificationError" xml:space="preserve">
    <value>此跟踪对象不应是任何响应或通知的一部分。</value>
  </data>
  <data name="MethodParameterCountDoesNotMatch" xml:space="preserve">
    <value>{0} 参数（排除任何 CancellationToken）：{1}，但请求提供 {2}</value>
  </data>
  <data name="CannotBeCalledAfterGetAsyncEnumerator" xml:space="preserve">
    <value>调用 GetAsyncEnumerator 后无法执行此操作。</value>
  </data>
  <data name="UnsupportedJsonRpcProtocolVersion" xml:space="preserve">
    <value>JSON-RPC 协议版本 {0} 不受支持。支持的协议版本为: {1}</value>
  </data>
  <data name="FatalExceptionWasThrown" xml:space="preserve">
    <value>服务器方法 {0} 引发了严重的异常: {1}</value>
  </data>
  <data name="UnexpectedTokenReadingHeader" xml:space="preserve">
    <value>分析标头时出现意外标记“{0}”。</value>
  </data>
  <data name="ConflictMethodSignatureAlreadyRegistered" xml:space="preserve">
    <value>已注册了具有相同名称和等效参数的方法。</value>
  </data>
  <data name="ErrorWritingJsonRpcResult" xml:space="preserve">
    <value>写入 JSON RPC 结果时出现错误: {0}: {1}</value>
  </data>
  <data name="ClientProxyTypeArgumentMustBeAnInterface" xml:space="preserve">
    <value>“{0}”不是接口。</value>
  </data>
  <data name="UnrecognizableMessage" xml:space="preserve">
    <value>无法将传入消息识别为 JSON-RPC 2.0 定义的消息类型。</value>
  </data>
  <data name="MarshaledObjectInNotificationError" xml:space="preserve">
    <value>通知中不能包含所跟踪的该对象。仅支持包括 "id" 属性的消息。</value>
  </data>
  <data name="UnsupportedGenericMethodsOnClientProxyInterface" xml:space="preserve">
    <value>不支持泛型方法。</value>
  </data>
  <data name="FindIProgressOfTError" xml:space="preserve">
    <value>无法将给定类型强制转换为 IProgress&lt;T&gt;</value>
  </data>
  <data name="UnknownTokenToMarshaledObject" xml:space="preserve">
    <value>此远程对象已不复存在。</value>
  </data>
  <data name="UnsupportedMethodReturnTypeOnClientProxyInterface" xml:space="preserve">
    <value>方法“{0}”具有不支持的返回类型“{1}”。只支持返回任务的方法。</value>
  </data>
</root>