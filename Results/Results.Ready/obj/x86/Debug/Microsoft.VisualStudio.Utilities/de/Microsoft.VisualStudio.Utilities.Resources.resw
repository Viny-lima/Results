<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Error_InsufficientSourceParameters" xml:space="preserve">
    <value>{0}.{1}: Der Konverter benötigt {2} Quellparameter, es wurden {3} Quellparameter angegeben.</value>
  </data>
  <data name="Error_InvalidExtensionNoLeadingPeriod" xml:space="preserve">
    <value>Das erste Zeichen der Erweiterung muss ein Punkt ('.') sein.</value>
  </data>
  <data name="Error_FlagNotRegistered" xml:space="preserve">
    <value>Nur registrierte Funktionsflags können festgelegt werden</value>
  </data>
  <data name="Error_InvalidMessageVersionHeader" xml:space="preserve">
    <value>Der Nachrichtenversionsheader ist aufgrund des aktuellen Zustands ungültig.</value>
  </data>
  <data name="ValidateError_StringEmpty" xml:space="preserve">
    <value>Die Zeichenfolge ist leer.</value>
  </data>
  <data name="Error_InsufficientTypeParameters" xml:space="preserve">
    <value>{0}.{1}: Der Konverter benötigt {2} Typparameter, es wurden {3} Typparameterangegeben.</value>
  </data>
  <data name="Error_InvalidNullableTypeCode" xml:space="preserve">
    <value>Ungültiger Nullable-Typcode {0}.</value>
  </data>
  <data name="MisplacedSettingPathWildcard" xml:space="preserve">
    <value>Platzhalter sind nur am Ende von Eigenschaftennamen zugelassen.</value>
  </data>
  <data name="Error_TargetNotExtendingType" xml:space="preserve">
    <value>{1}.{2}: Unerwarteter Zieltyp:{0}Erwarteter Zieltyp: {3}{0}Tatsächlich Zieltyp: {4}</value>
  </data>
  <data name="JsonSerializationFailed" xml:space="preserve">
    <value>Objekt konnte nicht als JSON serialisiert werden.</value>
  </data>
  <data name="Error_NullSerializerFieldCodeNullable" xml:space="preserve">
    <value>Der Wert eines Felds „SerializerFieldCode.Nullable“ darf nicht NULL sein. Nullwerte sollten stattdessen mit „SerializerFieldCode.NullableType“ oder „Nil“ codiert werden.</value>
  </data>
  <data name="Error_DeserializationCallbackFailure" xml:space="preserve">
    <value>Der Delegat hat die geschriebene Datenmenge nicht gelesen.</value>
  </data>
  <data name="Error_InvalidExtensionTooManyPeriods" xml:space="preserve">
    <value>Die Erweiterung darf nur einen einzigen Punkt ('.') enthalten.</value>
  </data>
  <data name="ValidateError_InvalidValue_Format" xml:space="preserve">
    <value>Der Argumentwert {0} ist nicht der erwartete Wert {1}.</value>
  </data>
  <data name="Error_NeedStreamCountOrStorageSize" xml:space="preserve">
    <value>Es muss mindestens ein Wert, entweder für maxStreamCount oder maxStorageSize, größer als Null sein</value>
  </data>
  <data name="Error_InvalidRootPath" xml:space="preserve">
    <value>Dies ist möglicherweise nicht der Stammpfad.</value>
  </data>
  <data name="ValidateError_PathNotNormalized_Format" xml:space="preserve">
    <value>Der Pfad \"{0}\" ist nicht normalisiert.</value>
  </data>
  <data name="Error_MaximumObjectIdentifierExceeded" xml:space="preserve">
    <value>Der maximale Objektbezeichner wurde überschritten.</value>
  </data>
  <data name="ValidateError_UnexpectedValue_Format" xml:space="preserve">
    <value>Der Wert {0} ist für Argument {1} unerwartet.</value>
  </data>
  <data name="Error_NeedSuccessCode" xml:space="preserve">
    <value>Der Parameter "{0}" weist auf einen Fehler hin.</value>
  </data>
  <data name="ValidateError_InvalidOperation" xml:space="preserve">
    <value>Der Vorgang kann derzeit nicht ausgeführt werden. Das Objekt {0} ist nicht NULL.</value>
  </data>
  <data name="Error_DependsOnPropertyNotFound" xml:space="preserve">
    <value>"{0}.{1}" hängt von einer Eigenschaft ab, die nicht gefunden wurde: {2}</value>
  </data>
  <data name="ServiceUnavailable_Format" xml:space="preserve">
    <value>Der {0}-Dienst ist nicht verfügbar.</value>
  </data>
  <data name="Error_ConverterFunctionNotDefined" xml:space="preserve">
    <value>{0}: "{1}" ist für diesen Konverter nicht definiert.</value>
  </data>
  <data name="Error_MetadataMapShouldHaveSize" xml:space="preserve">
    <value>Die Metadatenzuordnung für {0} sollte die Größe {1} aufweisen.</value>
  </data>
  <data name="Error_InvalidTimestampKind" xml:space="preserve">
    <value>Ungültiger Zeitstempeltyp: {0}</value>
  </data>
  <data name="Error_UnexpectedStreamVersion" xml:space="preserve">
    <value>Unerwartete Datenstromversion: erwartete Version={0}, tatsächliche Version={1}</value>
  </data>
  <data name="Error_TargetAtOffsetNotExtendingType" xml:space="preserve">
    <value>{1}.{2}: Unerwarteter Typ bei Offset {5}:{0}Erwarteter Zieltyp: {3}{0}Tatsächlicher Zieltyp: {4}</value>
  </data>
  <data name="ValidateError_GuidEmpty" xml:space="preserve">
    <value>Die GUID ist leer.</value>
  </data>
  <data name="ValidateError_StringWhiteSpace" xml:space="preserve">
    <value>Die Zeichenfolge darf nicht NULL sein oder nur Leerstellen enthalten.</value>
  </data>
  <data name="Error_ThicknessConverter_InvalidValues" xml:space="preserve">
    <value>{0} erfordert 1, 2 oder 4 Eingabewerte.</value>
  </data>
  <data name="NormalizeError_InvalidPathChar" xml:space="preserve">
    <value>Der Pfad enthält ein ungültiges Zeichen.</value>
  </data>
  <data name="Error_InvalidStreamAccess" xml:space="preserve">
    <value>Ungültiger Datenstromzugriff: {0}</value>
  </data>
  <data name="Error_PrivateToSharedNameTranslatorReturnedNullOrEmpty" xml:space="preserve">
    <value>Der privat-bis-freigegebene Namensübersetzer gab null oder eine leere Zeichenfolge für die freigegebene Einstellung {0} aus.</value>
  </data>
  <data name="Error_InvalidPatternForFeatureName" xml:space="preserve">
    <value>Muss die Form {0} aufweisen</value>
  </data>
  <data name="ValidateError_BitmapNotBgra32" xml:space="preserve">
    <value>Die bereitgestellten Bitmapbits stellen kein vollständiges BGRA32-Bitmap dar.</value>
  </data>
  <data name="ValidateError_OutOfRange_Format" xml:space="preserve">
    <value>Der Wert {0} befindet sich außerhalb des zulässigen Bereichs von [{1},{2}].</value>
  </data>
  <data name="Error_ValueNotOfType" xml:space="preserve">
    <value>{1}.{2}: Unerwarteter Werttyp:{0}Erwarteter Typ: {3}{0}Tatsächlicher Typ: {4}</value>
  </data>
  <data name="Error_InvalidNameFilter" xml:space="preserve">
    <value>Der Namensfilter muss eine gültige LogId sein. Nur "?" und "*" dürfen als Platzhalterzeichen verwendet werden.</value>
  </data>
  <data name="Error_InvalidExternalClientProcessPid" xml:space="preserve">
    <value>{0} '{1}' wurde in der Serviceanfrage nicht angegeben oder enthielt keine gültige PID.</value>
  </data>
  <data name="Error_ValueAtOffsetNotOfType" xml:space="preserve">
    <value>{1}.{2}: Unerwarteter Werttyp bei Offset {5}:{0}Erwarteter Typ: {3}{0}Tatsächlicher Typ: {4}</value>
  </data>
  <data name="Error_InvalidMaxStreamCount" xml:space="preserve">
    <value>Null ist ein ungültiger Wert für die maximale Datenstromanzahl</value>
  </data>
  <data name="Error_InvalidMaxStorageSize" xml:space="preserve">
    <value>Null ist ein ungültiger Wert für die maximale Speichergröße</value>
  </data>
  <data name="Error_NoStreamStorageEvents" xml:space="preserve">
    <value>Ein Speicher, der IStreamStorageEvents&lt;TKey&gt; nicht implementiert, kann nicht überwacht werden</value>
  </data>
  <data name="Error_ThicknessConverter_InvalidTargetType" xml:space="preserve">
    <value>{0} unterstützt nur den Zieltyp "{1}".</value>
  </data>
  <data name="Error_FailedToUpdateInternalState" xml:space="preserve">
    <value>Interner Versionskonflikt beim Aktualisieren von Komponentenversionen im aktuellen Kontext.</value>
  </data>
  <data name="Error_CircularPropertyDependency" xml:space="preserve">
    <value>Es liegt eine Ringabhängigkeit für eine Eigenschaft vor: {0}</value>
  </data>
  <data name="Error_FailedToAcquireMutex" xml:space="preserve">
    <value>Auf das prozessübergreifende Mutex "{0}" konnte nicht zugegriffen werden.</value>
  </data>
</root>