<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Error_InsufficientSourceParameters" xml:space="preserve">
    <value>{0}.{1}: 转换器需要 {2} 源参数，提供的是 {3} 源参数。</value>
  </data>
  <data name="Error_InvalidExtensionNoLeadingPeriod" xml:space="preserve">
    <value>扩展名的第一个字符必须是句点(“.”)。</value>
  </data>
  <data name="Error_FlagNotRegistered" xml:space="preserve">
    <value>只能设置已注册的功能标志</value>
  </data>
  <data name="Error_InvalidMessageVersionHeader" xml:space="preserve">
    <value>根据当前状态，消息版本标头无效。</value>
  </data>
  <data name="ValidateError_StringEmpty" xml:space="preserve">
    <value>字符串为空。</value>
  </data>
  <data name="Error_InsufficientTypeParameters" xml:space="preserve">
    <value>{0}.{1}: 转换器需要 {2} 类型参数，提供的是 {3} 类型参数。</value>
  </data>
  <data name="Error_InvalidNullableTypeCode" xml:space="preserve">
    <value>可为 null 的类型代码 {0} 无效。</value>
  </data>
  <data name="MisplacedSettingPathWildcard" xml:space="preserve">
    <value>始终只允许在属性名结尾使用通配符。</value>
  </data>
  <data name="Error_TargetNotExtendingType" xml:space="preserve">
    <value>{1}.{2}: 意外的目标类型:{0}预期目标类型: {3}{0}实际目标类型: {4}</value>
  </data>
  <data name="JsonSerializationFailed" xml:space="preserve">
    <value>未能将对象序列化为 JSON。</value>
  </data>
  <data name="Error_NullSerializerFieldCodeNullable" xml:space="preserve">
    <value>SerializerFieldCode.Nullable 字段的值不能为 null，应改用 SerializerFieldCode.NullableType 或 Nil 对 null 值进行编码。</value>
  </data>
  <data name="Error_DeserializationCallbackFailure" xml:space="preserve">
    <value>委托未读取写入的数据量</value>
  </data>
  <data name="Error_InvalidExtensionTooManyPeriods" xml:space="preserve">
    <value>扩展名只能包含一个句点(“.”)。</value>
  </data>
  <data name="ValidateError_InvalidValue_Format" xml:space="preserve">
    <value>参数值 {0} 不是预期值 {1}。</value>
  </data>
  <data name="Error_NeedStreamCountOrStorageSize" xml:space="preserve">
    <value>maxStreamCount 或 maxStorageSize 中至少一个必须大于零</value>
  </data>
  <data name="Error_InvalidRootPath" xml:space="preserve">
    <value>这可能不是根路径。</value>
  </data>
  <data name="ValidateError_PathNotNormalized_Format" xml:space="preserve">
    <value>路径“{0}”未标准化。</value>
  </data>
  <data name="Error_MaximumObjectIdentifierExceeded" xml:space="preserve">
    <value>超过了最大对象标识符。</value>
  </data>
  <data name="ValidateError_UnexpectedValue_Format" xml:space="preserve">
    <value>值 {0} 不是参数 {1} 的预期值。</value>
  </data>
  <data name="Error_NeedSuccessCode" xml:space="preserve">
    <value>参数 {0} 表示失败。</value>
  </data>
  <data name="ValidateError_InvalidOperation" xml:space="preserve">
    <value>当前无法执行该操作。对象 {0} 不是 null。</value>
  </data>
  <data name="Error_DependsOnPropertyNotFound" xml:space="preserve">
    <value>找不到 {0}.{1} 所依赖的属性: {2}</value>
  </data>
  <data name="ServiceUnavailable_Format" xml:space="preserve">
    <value>{0} 服务不可用。</value>
  </data>
  <data name="Error_ConverterFunctionNotDefined" xml:space="preserve">
    <value>没有为该转换器定义 {0}: {1}。</value>
  </data>
  <data name="Error_MetadataMapShouldHaveSize" xml:space="preserve">
    <value>{0} 的元数据映射应具有大小 {1}。</value>
  </data>
  <data name="Error_InvalidTimestampKind" xml:space="preserve">
    <value>无效的时间戳类型: {0}</value>
  </data>
  <data name="Error_UnexpectedStreamVersion" xml:space="preserve">
    <value>意外的流版本: 预期版本={0}，实际版本={1}</value>
  </data>
  <data name="Error_TargetAtOffsetNotExtendingType" xml:space="preserve">
    <value>{1}.{2}: 偏移 {5} 处存在意外的目标类型:{0}预期目标类型: {3}{0}实际目标类型: {4}</value>
  </data>
  <data name="ValidateError_GuidEmpty" xml:space="preserve">
    <value>Guid 为空。</value>
  </data>
  <data name="ValidateError_StringWhiteSpace" xml:space="preserve">
    <value>字符串不可为 null 或只包含空格字符。</value>
  </data>
  <data name="Error_ThicknessConverter_InvalidValues" xml:space="preserve">
    <value>{0} 需要 1 个、2 个或 4 个输入值</value>
  </data>
  <data name="NormalizeError_InvalidPathChar" xml:space="preserve">
    <value>路径包含无效字符。</value>
  </data>
  <data name="Error_InvalidStreamAccess" xml:space="preserve">
    <value>无效的流访问: {0}</value>
  </data>
  <data name="Error_PrivateToSharedNameTranslatorReturnedNullOrEmpty" xml:space="preserve">
    <value>专用至共享的名称转换器对共享设置 {0} 返回 null 或空字符串。</value>
  </data>
  <data name="Error_InvalidPatternForFeatureName" xml:space="preserve">
    <value>必须为 {0} 形式</value>
  </data>
  <data name="ValidateError_BitmapNotBgra32" xml:space="preserve">
    <value>提供的位图位并不表示完整的 BGRA32 位图。</value>
  </data>
  <data name="ValidateError_OutOfRange_Format" xml:space="preserve">
    <value>值 {0} 位于可接受的[{1},{2}]范围之外。</value>
  </data>
  <data name="Error_ValueNotOfType" xml:space="preserve">
    <value>{1}.{2}: 意外的值类型:{0}预期类型: {3}{0}实际类型: {4}</value>
  </data>
  <data name="Error_InvalidNameFilter" xml:space="preserve">
    <value>名称筛选器必须是有效的 LogId, 并且只能使用 "?" 和 "*" 作为通配符.</value>
  </data>
  <data name="Error_InvalidExternalClientProcessPid" xml:space="preserve">
    <value>服务请求中未提供 {0}“{1}”，或者它不包含有效的 PID。</value>
  </data>
  <data name="Error_ValueAtOffsetNotOfType" xml:space="preserve">
    <value>{1}.{2}: 偏移 {5} 处存在意外的值类型:{0}预期类型: {3}{0}实际类型: {4}</value>
  </data>
  <data name="Error_InvalidMaxStreamCount" xml:space="preserve">
    <value>零是无效的最大流计数值</value>
  </data>
  <data name="Error_InvalidMaxStorageSize" xml:space="preserve">
    <value>零是无效的最大存储大小值</value>
  </data>
  <data name="Error_NoStreamStorageEvents" xml:space="preserve">
    <value>无法监视不会实现 IStreamStorageEvents&lt;TKey&gt; 的存储</value>
  </data>
  <data name="Error_ThicknessConverter_InvalidTargetType" xml:space="preserve">
    <value>{0} 仅支持目标类型 {1}</value>
  </data>
  <data name="Error_FailedToUpdateInternalState" xml:space="preserve">
    <value>更新当前上下文中的组件版本时检测到内部版本不匹配。</value>
  </data>
  <data name="Error_CircularPropertyDependency" xml:space="preserve">
    <value>存在循环属性依赖项: {0}</value>
  </data>
  <data name="Error_FailedToAcquireMutex" xml:space="preserve">
    <value>无法访问跨进程互斥“{0}”</value>
  </data>
</root>