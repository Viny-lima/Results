<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Error_InsufficientSourceParameters" xml:space="preserve">
    <value>{0}.{1} : Le convertisseur nécessite {2} paramètres sources, {3} paramètres sources fournis.</value>
  </data>
  <data name="Error_InvalidExtensionNoLeadingPeriod" xml:space="preserve">
    <value>Le premier caractère de l'extension doit être un point (« . »).</value>
  </data>
  <data name="Error_FlagNotRegistered" xml:space="preserve">
    <value>Vous pouvez uniquement définir les indicateurs de fonctionnalité qui ont été inscrits</value>
  </data>
  <data name="Error_InvalidMessageVersionHeader" xml:space="preserve">
    <value>L’en-tête de version du message n’est pas valide en fonction de l’état actuel.</value>
  </data>
  <data name="ValidateError_StringEmpty" xml:space="preserve">
    <value>La chaîne est vide.</value>
  </data>
  <data name="Error_InsufficientTypeParameters" xml:space="preserve">
    <value>{0}.{1} : Le convertisseur nécessite {2} paramètres de type, {3} paramètres de type fournis.</value>
  </data>
  <data name="Error_InvalidNullableTypeCode" xml:space="preserve">
    <value>Code de type Nullable non valide {0}</value>
  </data>
  <data name="MisplacedSettingPathWildcard" xml:space="preserve">
    <value>Les caractères génériques ne sont autorisés qu'à la fin des noms de propriétés.</value>
  </data>
  <data name="Error_TargetNotExtendingType" xml:space="preserve">
    <value>{1}.{2} : type de cible inattendu :{0}Type de cible attendu : {3}{0}Type de cible réel : {4}</value>
  </data>
  <data name="JsonSerializationFailed" xml:space="preserve">
    <value>Échec de la sérialisation de l'objet en tant que JSON.</value>
  </data>
  <data name="Error_NullSerializerFieldCodeNullable" xml:space="preserve">
    <value>La valeur d’un champ SerializerFieldCode.Nullable ne peut pas être Null. Les valeurs Null doivent être encodées avec SerializerFieldCode.NullableType ou Nil à la place.</value>
  </data>
  <data name="Error_DeserializationCallbackFailure" xml:space="preserve">
    <value>Le délégué n'a pas lu la quantité de données écrites</value>
  </data>
  <data name="Error_InvalidExtensionTooManyPeriods" xml:space="preserve">
    <value>L'extension ne peut contenir qu'un seul point (« . »).</value>
  </data>
  <data name="ValidateError_InvalidValue_Format" xml:space="preserve">
    <value>La valeur de l'argument {0} n'est pas la valeur attendue {1}.</value>
  </data>
  <data name="Error_NeedStreamCountOrStorageSize" xml:space="preserve">
    <value>maxStreamCount ou maxStorageSize doit être supérieur à zéro</value>
  </data>
  <data name="Error_InvalidRootPath" xml:space="preserve">
    <value>Il ne s'agit peut-être pas du chemin racine.</value>
  </data>
  <data name="ValidateError_PathNotNormalized_Format" xml:space="preserve">
    <value>Le chemin \"{0}\" n'est pas normalisé.</value>
  </data>
  <data name="Error_MaximumObjectIdentifierExceeded" xml:space="preserve">
    <value>L'identifiant maximal de l'objet est dépassé.</value>
  </data>
  <data name="ValidateError_UnexpectedValue_Format" xml:space="preserve">
    <value>La valeur {0} est inattendue pour l'argument {1}.</value>
  </data>
  <data name="Error_NeedSuccessCode" xml:space="preserve">
    <value>Le paramètre {0} indique une défaillance.</value>
  </data>
  <data name="ValidateError_InvalidOperation" xml:space="preserve">
    <value>L'opération ne peut pas être exécutée pour l'instant. L'objet {0} n'est pas null.</value>
  </data>
  <data name="Error_DependsOnPropertyNotFound" xml:space="preserve">
    <value>{0}.{1} dépend d'une propriété introuvable : {2}</value>
  </data>
  <data name="ServiceUnavailable_Format" xml:space="preserve">
    <value>Le service {0} n'est pas disponible.</value>
  </data>
  <data name="Error_ConverterFunctionNotDefined" xml:space="preserve">
    <value>{0} : {1} n'est pas défini pour ce convertisseur.</value>
  </data>
  <data name="Error_MetadataMapShouldHaveSize" xml:space="preserve">
    <value>Le mappage de métadonnées pour {0} doit avoir une taille {1}.</value>
  </data>
  <data name="Error_InvalidTimestampKind" xml:space="preserve">
    <value>Genre d'horodatage non valide : {0}</value>
  </data>
  <data name="Error_UnexpectedStreamVersion" xml:space="preserve">
    <value>Version de flux inattendue :  version attendue={0}, version réelle={1}</value>
  </data>
  <data name="Error_TargetAtOffsetNotExtendingType" xml:space="preserve">
    <value>{1}.{2} : type de cible inattendu au décalage {5} :{0}Type cible attendu : {3}{0}Type cible réel : {4}</value>
  </data>
  <data name="ValidateError_GuidEmpty" xml:space="preserve">
    <value>Le Guid est vide.</value>
  </data>
  <data name="ValidateError_StringWhiteSpace" xml:space="preserve">
    <value>La chaîne ne peut pas être null ou contenir uniquement des espaces blancs.</value>
  </data>
  <data name="Error_ThicknessConverter_InvalidValues" xml:space="preserve">
    <value>{0} nécessite 1, 2 ou 4 valeurs d'entrée</value>
  </data>
  <data name="NormalizeError_InvalidPathChar" xml:space="preserve">
    <value>Le chemin contient un caractère non valide.</value>
  </data>
  <data name="Error_InvalidStreamAccess" xml:space="preserve">
    <value>Accès à un flux non valide : {0}</value>
  </data>
  <data name="Error_PrivateToSharedNameTranslatorReturnedNullOrEmpty" xml:space="preserve">
    <value>Le traducteur de nom privé en partage a retourné une chaîne null ou vide pour le paramètre partagé {0}.</value>
  </data>
  <data name="Error_InvalidPatternForFeatureName" xml:space="preserve">
    <value>Doit avoir la forme {0}</value>
  </data>
  <data name="ValidateError_BitmapNotBgra32" xml:space="preserve">
    <value>Les bits d'image bitmap fournis ne représentent pas une image bitmap BGRA32 complète.</value>
  </data>
  <data name="ValidateError_OutOfRange_Format" xml:space="preserve">
    <value>La valeur {0} se situe hors de la plage acceptable [{1},{2}].</value>
  </data>
  <data name="Error_ValueNotOfType" xml:space="preserve">
    <value>{1}.{2} : type de valeur inattendu :{0}Type attendu : {3}{0}Type réel : {4}</value>
  </data>
  <data name="Error_InvalidNameFilter" xml:space="preserve">
    <value>Le filtre de nom doit être un LogId valide contenant uniquement les caractères génériques '?' et '*'.</value>
  </data>
  <data name="Error_InvalidExternalClientProcessPid" xml:space="preserve">
    <value>{0} '{1}' n’a pas été fourni dans la demande de service ou ne contenait pas de PID valide.</value>
  </data>
  <data name="Error_ValueAtOffsetNotOfType" xml:space="preserve">
    <value>{1}.{2} : type de valeur inattendu au décalage {5} :{0}Type attendu : {3}{0}Type réel : {4}</value>
  </data>
  <data name="Error_InvalidMaxStreamCount" xml:space="preserve">
    <value>Zéro n'est pas une valeur correcte pour le nombre de flux maximum</value>
  </data>
  <data name="Error_InvalidMaxStorageSize" xml:space="preserve">
    <value>Zéro n'est pas une valeur correcte pour la taille de stockage maximum</value>
  </data>
  <data name="Error_NoStreamStorageEvents" xml:space="preserve">
    <value>Impossible de surveiller un stockage qui ne prend pas en charge IStreamStorageEvents&lt;TKey&gt;</value>
  </data>
  <data name="Error_ThicknessConverter_InvalidTargetType" xml:space="preserve">
    <value>{0} prend uniquement en charge le type de cible {1}</value>
  </data>
  <data name="Error_FailedToUpdateInternalState" xml:space="preserve">
    <value>Incompatibilité de version interne détectée lors de la mise à jour des versions de composant dans le contexte actuel.</value>
  </data>
  <data name="Error_CircularPropertyDependency" xml:space="preserve">
    <value>Il existe une dépendance de propriété circulaire : {0}</value>
  </data>
  <data name="Error_FailedToAcquireMutex" xml:space="preserve">
    <value>Impossible d'accéder au mutex interprocessus '{0}'</value>
  </data>
</root>