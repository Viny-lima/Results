<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Error_InsufficientSourceParameters" xml:space="preserve">
    <value>{0}.{1}: konwerter wymaga następującej liczby parametrów źródłowych: {2}, liczba podanych parametrów źródłowych: {3}.</value>
  </data>
  <data name="Error_InvalidExtensionNoLeadingPeriod" xml:space="preserve">
    <value>Pierwszym znakiem rozszerzenia musi być kropka („.”).</value>
  </data>
  <data name="Error_FlagNotRegistered" xml:space="preserve">
    <value>Możliwe jest ustawienie tylko zarejestrowanych flag funkcji</value>
  </data>
  <data name="Error_InvalidMessageVersionHeader" xml:space="preserve">
    <value>Nagłówek wersji wiadomości jest nieprawidłowy na podstawie bieżącego stanu.</value>
  </data>
  <data name="ValidateError_StringEmpty" xml:space="preserve">
    <value>Ciąg jest pusty.</value>
  </data>
  <data name="Error_InsufficientTypeParameters" xml:space="preserve">
    <value>{0}.{1}: konwerter wymaga następującej liczby parametrów typu: {2}, liczba podanych parametrów typu: {3}.</value>
  </data>
  <data name="Error_InvalidNullableTypeCode" xml:space="preserve">
    <value>Nieprawidłowy kod {0} typu dopuszczającego wartość null.</value>
  </data>
  <data name="MisplacedSettingPathWildcard" xml:space="preserve">
    <value>Symbole wieloznaczne są dozwolone tylko na końcach nazw właściwości.</value>
  </data>
  <data name="Error_TargetNotExtendingType" xml:space="preserve">
    <value>{1}.{2}: nieoczekiwany typ docelowy:{0}Oczekiwany typ docelowy: {3}{0}Rzeczywisty typ docelowy: {4}</value>
  </data>
  <data name="JsonSerializationFailed" xml:space="preserve">
    <value>Nie można zserializować obiektu jako elementu JSON.</value>
  </data>
  <data name="Error_NullSerializerFieldCodeNullable" xml:space="preserve">
    <value>Wartość pola SerializerFieldCode.Nullable nie może być równa null. Zamiast tego wartości null powinny być kodowane przy użyciu metody SerializerFieldCode.NullableType lub Nil.</value>
  </data>
  <data name="Error_DeserializationCallbackFailure" xml:space="preserve">
    <value>Delegat nie odczytał ilości danych, którą zapisano</value>
  </data>
  <data name="Error_InvalidExtensionTooManyPeriods" xml:space="preserve">
    <value>Rozszerzenie może zawierać tylko jedną kropkę („.”).</value>
  </data>
  <data name="ValidateError_InvalidValue_Format" xml:space="preserve">
    <value>Wartość argumentu {0} nie jest oczekiwaną wartością {1}.</value>
  </data>
  <data name="Error_NeedStreamCountOrStorageSize" xml:space="preserve">
    <value>Co najmniej jedna wartość maxStreamCount lub maxStorageSize musi być większa niż zero</value>
  </data>
  <data name="Error_InvalidRootPath" xml:space="preserve">
    <value>Może to nie być ścieżka katalogu głównego.</value>
  </data>
  <data name="ValidateError_PathNotNormalized_Format" xml:space="preserve">
    <value>Ścieżka „{0}” nie jest znormalizowana.</value>
  </data>
  <data name="Error_MaximumObjectIdentifierExceeded" xml:space="preserve">
    <value>Przekroczono maksymalny identyfikator obiektu.</value>
  </data>
  <data name="ValidateError_UnexpectedValue_Format" xml:space="preserve">
    <value>Nieoczekiwana wartość {0} dla argumentu {1}.</value>
  </data>
  <data name="Error_NeedSuccessCode" xml:space="preserve">
    <value>Parametr {0} wskazuje niepowodzenie.</value>
  </data>
  <data name="ValidateError_InvalidOperation" xml:space="preserve">
    <value>Teraz nie można wykonać tej operacji. Obiekt {0} nie ma wartości null.</value>
  </data>
  <data name="Error_DependsOnPropertyNotFound" xml:space="preserve">
    <value>{0}.{1} zależy od właściwości, której nie można znaleźć: {2}</value>
  </data>
  <data name="ServiceUnavailable_Format" xml:space="preserve">
    <value>Usługa {0} jest niedostępna.</value>
  </data>
  <data name="Error_ConverterFunctionNotDefined" xml:space="preserve">
    <value>{0}: dla tego kontenera nie zdefiniowano elementu {1}.</value>
  </data>
  <data name="Error_MetadataMapShouldHaveSize" xml:space="preserve">
    <value>Mapa metadanych dla {0} powinna mieć rozmiar {1}.</value>
  </data>
  <data name="Error_InvalidTimestampKind" xml:space="preserve">
    <value>Nieprawidłowy typ sygnatury czasowej: {0}</value>
  </data>
  <data name="Error_UnexpectedStreamVersion" xml:space="preserve">
    <value>Nieoczekiwana wersja strumienia: wersja oczekiwana={0}, wersja rzeczywista={1}</value>
  </data>
  <data name="Error_TargetAtOffsetNotExtendingType" xml:space="preserve">
    <value>{1}.{2}: nieoczekiwany typ docelowy przy przesunięciu {5}:{0}Oczekiwany typ docelowy: {3}{0}Rzeczywisty typ docelowy: {4}</value>
  </data>
  <data name="ValidateError_GuidEmpty" xml:space="preserve">
    <value>Identyfikator Guid jest pusty.</value>
  </data>
  <data name="ValidateError_StringWhiteSpace" xml:space="preserve">
    <value>Ciąg nie może przyjąć wartości null ani zawierać samych białych znaków.</value>
  </data>
  <data name="Error_ThicknessConverter_InvalidValues" xml:space="preserve">
    <value>Element {0} wymaga 1, 2 lub 4 wartości wejściowych</value>
  </data>
  <data name="NormalizeError_InvalidPathChar" xml:space="preserve">
    <value>Ścieżka zawiera nieprawidłowy znak.</value>
  </data>
  <data name="Error_InvalidStreamAccess" xml:space="preserve">
    <value>Nieprawidłowy dostęp strumieniowy: {0}</value>
  </data>
  <data name="Error_PrivateToSharedNameTranslatorReturnedNullOrEmpty" xml:space="preserve">
    <value>Translator nazw prywatnych na nazwy udostępnione zwrócił wartość null lub pusty ciąg ustawienia udostępnionego {0}.</value>
  </data>
  <data name="Error_InvalidPatternForFeatureName" xml:space="preserve">
    <value>Wymagana forma: {0}</value>
  </data>
  <data name="ValidateError_BitmapNotBgra32" xml:space="preserve">
    <value>Dostarczona mapa bitowa nie przedstawia pełnej mapy bitowej BGRA32.</value>
  </data>
  <data name="ValidateError_OutOfRange_Format" xml:space="preserve">
    <value>Wartość {0} znajduje się poza dopuszczalnym zakresem [{1},{2}].</value>
  </data>
  <data name="Error_ValueNotOfType" xml:space="preserve">
    <value>{1}.{2}: nieoczekiwany typ wartości:{0}Oczekiwany typ: {3}{0}Rzeczywisty typ: {4}</value>
  </data>
  <data name="Error_InvalidNameFilter" xml:space="preserve">
    <value>Filtr nazwy musi być prawidłowym identyfikatorem LogId zawierającym tylko znaki „?” i „*” jako symbole wieloznaczne.</value>
  </data>
  <data name="Error_InvalidExternalClientProcessPid" xml:space="preserve">
    <value>Element {0} „{1}” nie został podany w żądaniu usługi lub nie zawierał prawidłowego identyfikatora PID.</value>
  </data>
  <data name="Error_ValueAtOffsetNotOfType" xml:space="preserve">
    <value>{1}.{2}: nieoczekiwany typ wartości przy przesunięciu {5}:{0}Oczekiwany typ: {3}{0}Rzeczywisty typ: {4}</value>
  </data>
  <data name="Error_InvalidMaxStreamCount" xml:space="preserve">
    <value>Zero jest nieprawidłową wartością maksymalnej liczby strumieni</value>
  </data>
  <data name="Error_InvalidMaxStorageSize" xml:space="preserve">
    <value>Zero jest nieprawidłową wartością maksymalnego rozmiaru magazynu</value>
  </data>
  <data name="Error_NoStreamStorageEvents" xml:space="preserve">
    <value>Nie można monitorować magazynu bez implementacji interfejsu IStreamStorageEvents&lt;TKey&gt;</value>
  </data>
  <data name="Error_ThicknessConverter_InvalidTargetType" xml:space="preserve">
    <value>Element {0} obsługuje tylko typ docelowy {1}</value>
  </data>
  <data name="Error_FailedToUpdateInternalState" xml:space="preserve">
    <value>Wykryto wewnętrzną niezgodność wersji podczas aktualizowania wersji składników w bieżącym kontekście.</value>
  </data>
  <data name="Error_CircularPropertyDependency" xml:space="preserve">
    <value>Istnieje cykliczna zależność właściwości: {0}</value>
  </data>
  <data name="Error_FailedToAcquireMutex" xml:space="preserve">
    <value>Nie można uzyskać dostępu do międzyprocesowego wykluczania wzajemnego „{0}”</value>
  </data>
</root>