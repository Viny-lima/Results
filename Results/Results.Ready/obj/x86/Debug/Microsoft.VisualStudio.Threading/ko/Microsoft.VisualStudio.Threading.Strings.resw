<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="SyncContextFrameMismatchedAffinity" xml:space="preserve">
    <value>이 프레임은 다른 인스턴스에 이미 사용되었습니다.</value>
  </data>
  <data name="JoinableTaskContextAndCollectionMismatch" xml:space="preserve">
    <value>JoinableTask는 이 컬렉션이 인스턴스화된 컨텍스트에 속하지 않습니다.</value>
  </data>
  <data name="LazyValueFaulted" xml:space="preserve">
    <value>생성하는 동안 값을 만드는 시간이 지연되어 오류가 발생했습니다.</value>
  </data>
  <data name="SwitchToMainThreadFailedToReachExpectedThread" xml:space="preserve">
    <value>주 스레드로 전환하려 했지만 필요한 스레드에 도달하지 못했습니다. JoinableTaskContext가 잘못된 스레드에서 초기화되었거나 Post 메서드가 주 스레드에서 해당 대리자를 실행하지 않는 SynchronizationContext를 사용하여 초기화되었나요?</value>
  </data>
  <data name="PushFromWrongThread" xml:space="preserve">
    <value>메시지 펌프는 원래 스레드에서만 실행할 수 있습니다.</value>
  </data>
  <data name="CannotUpgradeNonUpgradeableLock" xml:space="preserve">
    <value>호출자에 업그레이드할 수 없는 읽기 잠금이 있으며 이 잠금을 업그레이드할 수 없습니다.</value>
  </data>
  <data name="MultipleContinuationsNotSupported" xml:space="preserve">
    <value>여러 연속 작업은 지원되지 않습니다.</value>
  </data>
  <data name="WriteLockOutlived" xml:space="preserve">
    <value>중첩된 읽기 잠금이 쓰기 잠금보다 더 오래 지속되는데, 이는 허용되지 않습니다.</value>
  </data>
  <data name="JoinableTaskContextNodeAlreadyRegistered" xml:space="preserve">
    <value>이 노드는 이미 등록되었습니다.</value>
  </data>
  <data name="InvalidLock" xml:space="preserve">
    <value>유효한 잠금에 대해서만 이 작업을 실행할 수 있습니다.</value>
  </data>
  <data name="SemaphoreAlreadyHeld" xml:space="preserve">
    <value>세마포가 이미 보류되었으며 재입력 설정이 '{0}'입니다.</value>
  </data>
  <data name="NotAllowedUnderURorWLock" xml:space="preserve">
    <value>AsyncReaderWriterLock으로 인해 업그레이드 가능한 활성 읽기 또는 쓰기 잠금이 있으면 이 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="SemaphoreMisused" xml:space="preserve">
    <value>이 세마포는 잘못 사용되어 더 이상 사용할 수 없습니다.</value>
  </data>
  <data name="LockCompletionAlreadyRequested" xml:space="preserve">
    <value>이 잠금은 이미 완료로 표시되었습니다.  이제 새로운 최상위 잠금을 처리할 수 없습니다.</value>
  </data>
  <data name="InvalidAfterCompleted" xml:space="preserve">
    <value>완료 상태로 이미 전환되었습니다.</value>
  </data>
  <data name="FrameMustBePushedFirst" xml:space="preserve">
    <value>이 인스턴스를 먼저 푸시해야 합니다.</value>
  </data>
  <data name="STAThreadCallerNotAllowed" xml:space="preserve">
    <value>이 작업은 STA 스레드에서 완료할 수 없습니다.</value>
  </data>
  <data name="ValueFactoryReentrancy" xml:space="preserve">
    <value>값 팩토리가 같은 인스턴스의 값을 호출했습니다.</value>
  </data>
  <data name="LazyValueNotCreated" xml:space="preserve">
    <value>값을 만드는 시간이 지연되어 값이 아직 생성되지 않았습니다.</value>
  </data>
  <data name="AppliedSynchronizationContextNotAllowed" xml:space="preserve">
    <value>적용된 SynchronizationContext로 스레드 잠금을 가져오는 것은 허용되지 않습니다.</value>
  </data>
  <data name="InvalidWithoutLock" xml:space="preserve">
    <value>잠금이 필요합니다.</value>
  </data>
  <data name="SemaphoreStackNestingViolated" xml:space="preserve">
    <value>재입력 설정이 '{0}'이면 중첩된 세마포 요청이 LIFO 순서로 릴리스되어야 합니다.</value>
  </data>
  <data name="DangerousReadLockRequestFromWriteLockFork" xml:space="preserve">
    <value>쓰기 잠금 분기로부터의 읽기 잠금 요청은 위험합니다.</value>
  </data>
  <data name="QueueEmpty" xml:space="preserve">
    <value>큐가 비어 있습니다.</value>
  </data>
  <data name="SyncContextNotSet" xml:space="preserve">
    <value>주 스레드에 연결할 SynchronizationContext가 설정되지 않았습니다.</value>
  </data>
</root>